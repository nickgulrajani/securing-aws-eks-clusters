name: eks-security-dryrun

on:
  push:
    branches: ["main"]
  pull_request:

jobs:
  dryrun:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Create tfvars if missing (no heredoc/backslashes)
      - name: Ensure tfvars/eks.tfvars exists
        run: |
          set -euo pipefail
          mkdir -p tfvars
          if [ ! -f tfvars/eks.tfvars ]; then
            : > tfvars/eks.tfvars
            echo 'project           = "eks-security"'        >> tfvars/eks.tfvars
            echo 'environment       = "dryrun"'              >> tfvars/eks.tfvars
            echo 'aws_region        = "us-east-1"'           >> tfvars/eks.tfvars
            echo 'name_prefix       = "ekssec"'              >> tfvars/eks.tfvars
            echo 'enable_eks        = true'                  >> tfvars/eks.tfvars
            echo 'private_subnet_ids = ["subnet-aaaa1111", "subnet-bbbb2222"]' >> tfvars/eks.tfvars
            echo 'cluster_role_arn   = "arn:aws:iam::111111111111:role/placeholder-eks-role"' >> tfvars/eks.tfvars
          fi
          echo "tfvars/eks.tfvars ready"

      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform fmt & validate
        run: |
          terraform -chdir=terraform init -backend=false
          terraform -chdir=terraform fmt -recursive
          terraform -chdir=terraform validate

      - name: Terraform plan (no apply, no costs)
        env:
          AWS_ACCESS_KEY_ID: dummy
          AWS_SECRET_ACCESS_KEY: dummy
          AWS_REGION: us-east-1
        run: |
          set -euo pipefail
          terraform -chdir=terraform init -backend=false
          terraform -chdir=terraform plan -refresh=false \
            -var-file=../tfvars/eks.tfvars \
            -out=tfplan.binary
          terraform -chdir=terraform show -json tfplan.binary > tfplan.json
          terraform -chdir=terraform show tfplan.binary | sed -n '1,140p'

      # Gates derived from plan JSON (fast, zero-cost)
      - name: Gate - EKS must use KMS for secrets
        run: |
          set -euo pipefail
          HAS_ENC=$(jq -r '
            any(.resource_changes[]?;
                .type=="aws_eks_cluster" and
                (.change.after.encryption_config // [] | length) > 0
            )' tfplan.json)
          [ "$HAS_ENC" = "true" ] || { echo "::error::Missing EKS KMS encryption_config"; exit 1; }
          echo "OK: EKS encryption_config present."

      - name: Gate - EKS endpoint must be private
        run: |
          set -euo pipefail
          PRIV=$(jq -r '
            any(.resource_changes[]?;
                .type=="aws_eks_cluster" and
                ((.change.after.vpc_config | if type=="array" then .[0] else . end).endpoint_public_access == false)
            )' tfplan.json)
          [ "$PRIV" = "true" ] || { echo "::error::EKS endpoint_public_access must be false"; exit 1; }
          echo "OK: EKS private endpoint enforced."

      - name: Gate - GuardDuty detector must be created
        run: |
          set -euo pipefail
          HAS_GD=$(jq -r '
            any(.resource_changes[]?; .type=="aws_guardduty_detector" and (.change.actions | index("create")))
          ' tfplan.json)
          [ "$HAS_GD" = "true" ] || { echo "::error::GuardDuty detector not present in plan"; exit 1; }
          echo "OK: GuardDuty detector present."

      - name: Gate - required tags on taggable resources
        run: |
          set -euo pipefail
          REQUIRED='["Project","Environment","Owner","CostCenter"]'
          MISSING=$(
            jq -r --argjson req "$REQUIRED" '
              def ensure_obj(x): if (x|type)=="object" then x else {} end;
              [
                .resource_changes[]?
                | select(.change.actions | index("create"))
                | . as $rc
                | (ensure_obj($rc.change.after)) as $after
                | ($after.tags_all // $after.tags // null) as $tags
                | select($tags != null)
                | {addr: $rc.address, type: $rc.type,
                   missing: [$req[] | select( ($tags[.] // null) == null )]}
                | select(.missing | length > 0)
                | "\(.addr) (\(.type)) missing: \(.missing|join(", "))"
              ] | .[]
            ' tfplan.json
          )
          if [ -n "$MISSING" ]; then
            echo "::error::Missing required tags:"; echo "$MISSING"; exit 1
          fi
          echo "OK: required tags present on taggable resources."

      # OPA checks for your k8s manifests (no cluster required)
      - name: Conftest (OPA) - validate Kubernetes manifests
        run: |
          set -euo pipefail
          test -d k8s/manifests
          test -d k8s/policy
          docker run --rm -v "$PWD/k8s:/project" openpolicyagent/conftest:latest \
            test /project/manifests --policy /project/policy
          echo "OK: OPA policy checks passed."

      - name: Quick static checks for required objects
        run: |
          set -euo pipefail
          grep -q 'pod-security.kubernetes.io/enforce: "restricted"' k8s/manifests/psa-namespaces.yaml
          grep -q "^kind: NetworkPolicy" k8s/manifests/networkpolicies.yaml
          grep -q "^kind: ClusterRole" k8s/manifests/rbac.yaml
          echo "OK: Required K8s objects present."

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: eks-security-dryrun-artifacts
          path: |
            terraform/tfplan.binary
            tfplan.json
            k8s/manifests
            k8s/policy
          if-no-files-found: error
